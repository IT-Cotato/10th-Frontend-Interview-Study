## 🖊️ 시작하며…

스터디에 참여하면서 **브라우저 동작 원리**에 대해 처음으로 제대로 공부하게 되었다. 원래 주제는 **브라우저 렌더링의 원리**였지만, 공부를 하다 보니 이 주제가 생각보다 방대하고 깊이 있는 것임을 깨달았다. 그래서 어디까지 공부해야 할지, 어떤 부분까지 정리해야 할지 고민이 많았다.

렌더링이 언제, 어떻게 일어나는지 조사하면서 단순히 렌더링 과정만 다루기보다는 **브라우저의 전체적인 동작 원리**를 함께 정리하는 것이 더 이해하기 쉬울 것 같아 주제를 조금 확장하게 되었다.

하지만 처음부터 너무 깊게 들어가면 오히려 이해가 어려워질 것 같아, 적당한 범위에서 최대한 쉽게 내용을 정리해 보았다.

## 💻 1. 웹 브라우저의 역할과 구조

### 웹 브라우저의 주요 기능

웹 브라우저의 주요 기능은 사용자가 선택한 자원을 서버에 요청하고 브라우저에 표시하는 것이다. \*\*\*\*이때 자원은 HTML 문서, PDF, 이미지 등 다양한 형태일 수 있고 자원의 주소는 URL에 의해 정해진다.

### 브라우저의 기본 구조

![](https://velog.velcdn.com/images/yongaricode/post/4de5292e-de1a-4f55-9db5-cf5598193369/image.png)

- 사용자 인터페이스: 주소 표시줄, 이전/다음 버튼, 북마크 등 페이지 뷰 이외의 다른 부분
- 브라우저 엔진: 사용자 인터페이스와 렌더링 엔진 사이 동작을 제어
- **렌더링 엔진: HTML, CSS를 파싱해 화면에 요청한 컨텐츠를 표시**
- 통신: HTTP 요청과 같은 네트워크 호출에 사용됨
- JS 엔진: 자바스크립트 코드를 해석하고 실행
- UI 백엔드: 기본적인 위젯을 그림
- 자료 저장소: 쿠키 등을 저장하는 웹 데이터베이스

## 📡 2. 브라우저와 서버 간의 통신 과정

위에서 말했듯, 웹 브라우저는 사용자가 입력한 URL을 기반으로 서버에 요청을 보내고, 서버에서 받은 데이터를 해석하여 웹 페이지를 렌더링하는 역할을 수행한다. 이 과정을 자세히 살펴보겠다.

### 2-1. 주소창에 입력한 텍스트 확인 (검색어 vs URL)

사용자가 **구글**을 방문하고 싶어서 주소창에 `google.com`을 입력했을 때, 브라우저는 주소창에 입력된 텍스트가 URL인지, 검색어인지 우선적으로 확인한다. 현재 대부분의 브라우저는 주소창을 검색창으로도 쓰기 때문이다.

- 만약 입력한 텍스트가 **검색어**라면, 브라우저는 검색 엔진의 URL에 검색어를 포함한 주소로 페이지를 이동시킨다.
- 만약 입력한 텍스트가 **URL**이라면, 브라우저 엔진에서 **네트워크 호출을** 실행한다.

### 2-2 네트워크 호출

사용자가 URL을 입력한 경우, 브라우저는 사이트에 접속하기 위해 네트워크 요청을 보내야한다. 웹 브라우저와 웹 서버는 서로 다른 컴퓨터에 위치하기 때문에, 브라우저가 웹 서버에 연결하려면 해당 서버의 주소를 알아야 합니다.

브라우저는 사용자가 쉽게 기억할 수 있도록 `google.com`과 같은 도메인 이름을 사용하지만, 실제로 서버와 통신하기 위해서는 이 도메인에 대응하는 IP주소가 필요하다. 이를 위해 **DNS(Domain Name Server)**를 사용하여 도메인 이름을 IP 주소로 변환한다. 브라우저는 DNS 서버에 해당 도메인의 IP 주소를 요청하고, DNS는 이에 대한 응답으로 IP 주소를 제공한다.

![](https://velog.velcdn.com/images/yongaricode/post/0f699e22-c82d-477e-9534-e89c7748ce7b/image.png)

IP주소를 받아서 확인한 후, 브라우저는 해당 서버에 HTTP 요청(Request)를 보낸다. 이 요청은 클라이언트가 원하는 페이지를 보여달라는 의미를 담고 있다. 서버는 요청을 수신하고, 클라이언트가 요청한 데이터를 준비하여 HTTP 응답을 반환한다. 이 응답에는 해당 페이지를 표시하는 데 필요한 HTML, CSS, 이미지, 스크립트 파일 등이 포함되어 있다.

![](https://velog.velcdn.com/images/yongaricode/post/76f2c536-1235-4344-b9b5-485f90eab484/image.png)

## 🎨 3. 렌더링 과정

브라우저 엔진은 서버로부터 받은 HTTP 응답 데이터에 악성 바이러스나 기타 문제가 없는지 먼저 검사한다. 이 데이터는 바이트 형태의 텍스트 문서이기 때문에, 브라우저에서 바로 화면에 표시될 수 없다. 따라서 브라우저 엔진은 렌더링 엔진에게 해당 데이터를 해석하고, 웹 페이지를 화면에 띄울 것을 요청한다.

렌더링 엔진은 요청을 받은 후, 다음과 같은 과정을 통해 렌더링 프로세스를 수행한다.

![](https://velog.velcdn.com/images/yongaricode/post/b9f59214-eb7d-4676-b052-f3c4218557ff/image.png)

### 📍 파싱이란?

렌더링 과정을 이해하기 위해, 파싱의 개념을 먼저 알아야한다. 앞서 말했듯이, 브라우저는 HTML, CSS 등 단순한 텍스트 파일을 읽지 못하므로, 이를 브라우저가 이해할 수 있는 구조로 변환해주는 과정이 반드시 필요하다. 이를 파싱**(Parsing)**이라 한다.

### 3-1. HTML 파싱 → DOM 트리 생성

렌더링 엔진이 HTML 문서를 수신하면, HTML 파서는 이를 위에서부터 읽어 내려가며 파싱을 진행하고, 그 결과물로 **DOM 트리**를 생성한다.

- **HTML 파싱 과정**

  ![](https://velog.velcdn.com/images/yongaricode/post/f3c027a7-9191-4b12-a3c8-1b3127a879d6/image.png)

  1.  서버에서 **바이트 형태**의 HTML 문서를 받는다.
  2.  저장된 인코딩 방식(UTF-8)에 따라 이를 **문자열**로 변환한다.
  3.  변환된 문자열을 **토큰**으로 분해한다.
  4.  토큰을 내용에 따라 **객체**로 변환하여 각 **노드**들을 생성한다.
  5.  노드를 **트리 구조**로 구성하여 DOM 트리를 생성한다.

렌더링 엔진은 사용자의 만족도를 높이기 위해 **모든** **HTML을 파싱할 때까지 기다리지 않고** 파싱 이후의 과정인 배치와 그리기를 미리 진행한다.

### 3-2. CSS 파싱 → CSSOM 트리 생성

렌더링 엔진은 HTML문서를 순차적으로 파싱하며 DOM을 생성하다가, CSS를 로드하는 `link` 태그나 `style` 태그를 만나면 **DOM 생성을 중지**하고 CSS 파싱을 시작한다.

CSS 파서는 서버에서 수신받은 CSS 문서를 파싱하여 CSSOM 트리를 생성하는데, 이 과정은 기본적으로 HTML 파싱 과정과 동일하다.

- **CSS 파싱 과정**

  ![](https://velog.velcdn.com/images/yongaricode/post/0b1068d2-827b-412e-a058-05e92655c540/image.png)

  CSSOM 트리의 노드는 DOM 트리 요소의 선택자에 맞춰 적용될 CSS 스타일 정보가 포함되어 있다.

  1.  서버에서 **바이트 형태**의 CSS 문서를 받는다.
  2.  저장된 인코딩 방식(UTF-8)에 따라 이를 **문자열**로 변환한다.
  3.  변환된 문자열을 **토큰**으로 분해한다.
  4.  토큰을 내용에 따라 **객체**로 변환하여 각 **노드**들을 생성한다**.**
  5.  노드를 **트리 구조**로 구성하여 CSSOM 트리를 생성한다.

### 3-3. JavaScript 파싱

렌더링 엔진은 HTML 파싱 과정에서 `script` 태그를 만나면 **DOM 생성을 중지하고** 해당 JavaScript 리소스를 브라우저 엔진으로부터 받아온다. 이후 **JavaScript 엔진**에게 제어권을 넘겨준다.

- **JS 파싱 과정**
  1. 받아온 JS 코드를 토크나이저가 어휘 분석하여 **토큰**들로 분해한다.
  2. 파서가 토큰들을 구문 분석하여 **AST(추상 구문 트리)**로 파싱한다.
  3. 바이트 코드 생성기가 AST를 **바이트 코드**로 변환한다.
  4. 인터프리터에 의해 바이트 코드를 실행한다.

JavaScript 파싱이 종료되면 렌더링 엔진은 다시 제어권을 돌려받고 DOM 생성을 이어나간다.

`script` 태그를 `body`의 중간에 작성할 경우, HTML 파싱이 끝나지 않은 상태에서 JavaScript로 인해 DOM이 조작되어 에러가 발생할 수 있다.

따라서 `script` 태그는 `body` 태그 내부의 최하단에 위치시켜야한다. (혹은 `script` 태그에 `defer`나 `async` 속성을 부여하는 방법도 있다.)

![](https://velog.velcdn.com/images/yongaricode/post/a76fbf20-4d93-4894-9cbf-3d2b447d11fc/image.png "asnyc와 defer 속성을 부여했을 때 script 진행 순서")

    asnyc와 defer 속성을 부여했을 때 script 진행 순서

### 3-4. Render Tree 생성 (Attachment)

HTML과 CSS의 파싱 과정이 모두 끝나면, 각각의 결과물인 DOM 트리와 CSSOM 트리를 서로 결합하여 렌더 트리(Render Tree)를 생성한다.

![](https://velog.velcdn.com/images/yongaricode/post/84b0486f-5c65-4835-9e5e-47345965b04f/image.png)

- **렌더 트리 생성 과정**
  1. DOM의 루트부터 노드 각각을 모두 탐색한다.
     - 화면에 표시되지 않는 일부 노드들(script, meta 태그 등)은 렌더 트리에서 제외된다.
     - CSS 속성 중 `display:none` 같이 화면에서 숨겨지는 속성도 렌더 트리에서 제외된다.
  2. 화면에 보여지는 나머지 노드에 CSSOM 규칙을 찾아 일치하는 스타일을 적용한다.
  3. 화면에 표시되는 노드를 콘텐츠 및 계산된 스타일과 함께 렌더트리로 생성한다.

### 3-5. Layout

렌더 트리 생성이 끝나면, 전체적인 웹 페이지 화면 안에서 렌더 트리 내 각 노드의 위치, 크기를 계산하고 이를 화면에 배치하는 레이아웃(Layout) 과정이 진행된다.

즉, 레이아웃은 **렌더 트리의 노드들을 화면에 배치**하는 과정이다.

이때, 모든 상대적인 값(`%`, `rem`, `vh`)으로 할당된 값들은 절대적인 값인 `px`단위로 변환된다.

- **글로벌 레이아웃**
  : 전체의 배치 과정이 필요한 경우
  - 맨 처음에 레이아웃이 발생할 때
  - 초기 배치 이후 font와 같은 전역 스타일이 변경될 때
  - 창이 리사이즈될 때
- **로컬 레이아웃**
  : 일부의 배치 과정만 변경하면 되는 경우
  - 일부 DOM 노드에만 변경이 생길 때

→ 로컬 레이아웃은 일부 변경만으로 전체 배치과정이 다시 일어나 불필요한 낭비가 발생하는 상황을 막아준다.

### 3-6. Paint

마지막으로, 레이아웃 과정에서 계산된 정보들을 바탕으로 각 노드를 화면에 그려주는 페인트(Paint) 과정이 진행된다. 이 Painting 메서드는 렌더 트리의 각 노드를 화면의 실제 픽셀로 나타날 때 호출된다.

- **그리기 순서**
  : 요소는 화면에 뒤에서 앞으로 그려지는데, 순서는 다음과 같다.
  1. 배경 색
  2. 배경 이미지
  3. 테두리
  4. 자식 요소
  5. 아웃라인

페인트의 과정 중 화면의 특정 위치에 여러 개의 노드가 함께 그려지는 경우, 여러 레이어를 만들고 이를 다시 합성하는 방식으로 작업이 이루어진다.

그리고 페인트 과정이 끝나면 브라우저 화면에 페이지가 보여진다!

## 🖊️ 마치며…

이번 브라우저 동작 원리를 탐구하며 CS 지식의 중요성을 크게 느꼈다. 생각보다 모르는 것이 많아 자료를 하나하나 검색하는 데 시간이 오래 걸렸다. 그래서 더 배움의 필요성을 느꼈고, 나중에 이 주제를 다시 공부해보고 싶다는 마음이 커졌다. 그때는 이번에 놓쳤던 부분들을 이해할 수 있으면 좋겠다.

## 📃 Reference

> https://velog.io/@thyoondev/웹-브라우저의-동작원리를-알아보자 > https://velog.io/@sylagape1231/주소창에-naver.com을-치면-일어나는-일을-쉽게-이해해보자 > https://velog.io/@tnehd1998/주소창에-www.google.com을-입력했을-때-일어나는-과정 > https://opendeveloper.tistory.com/entry/FrontEnd-지식브라우저-렌더링-원리와-순서성능-최적화-고려사항 > https://basemenks.tistory.com/292 > https://inpa.tistory.com/entry/🌐-js-async > https://developerpearl.tistory.com/56 > https://velog.io/@zaman17/기술면접대비-브라우저-렌더링-순서와-원리 > https://velog.io/@eunnbi/DNS와-작동-원리
